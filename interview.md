# 复习路径
面经：
https://github.com/huihut/interview
https://blog.csdn.net/adminpd/article/details/122934938

# 1 语言基础
阅读书籍：
effective cpp


# 2 操作系统
看看ostep什么的

# 3 计算机网络




# 4 数据库 ---------------------
# 4.1 mysql

# 4.2 redis
参考：
- https://blog.csdn.net/adminpd/article/details/122934938
- https://juejin.cn/post/6844904017387077640 (推荐)
- 做一个总结
## 基本概念
- 1 为啥快?
  - 1. 基于内存
  - 2. 单线程，减少上下文切换，同时保证原子性；
  - 3. IO多路复用；
  - 4. 高级数据结构（如 SDS、Hash以及跳表等）。
- 2 为啥单线程？
  - 因为 Redis 是基于内存的操作，CPU 不会成为 Redis 的瓶颈，而最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。
  - 分点说：
    - 1. 不会带来多线程锁的性能开销
    - 2. 单线程更容易做多进程集群方案
- 3 缓存穿透、击穿、雪崩？解决方案 https://segmentfault.com/a/1190000039300423
  - 穿透：查询数据不存在，透过redis直接把并发压力给到了数据库，容易崩溃，也就是穿透到了数据库
    - solve 1: 接口处校验数据合法
    - solve 2: 对应的key缓存为null，直接返回
    - solve 3: 在redis层前面加上bloomFilter: 可以快速判断key是否存在，存在才会去访问redis和db
    - solve 4: 对ip的恶意访问(如超过人为请求速度)采取限制策略
  - 击穿：热门key失效瞬间，大并发传入到db，也就是这个数据没办法被redis拦住然后高并发进入了数据库，就叫击穿
    - sovle 1: 热点数据设置成永不过期
    - sovle 2: 当第一次请求热点数据，用互斥锁锁住其他请求，查询到了数据缓存到redis，这样其他请求都能够从redis中拿数据了
  - 雪崩：当大面积的key在redis上失效，请求直接打到了db上
    - solve 1: key的失效时间加上随机值
    - sovle 2: 如果是redis down了
      - 使用集群缓存（解决容量优先问题），主从（数据备份）加哨兵（sentinel负责监控，通知，故障转移，实现高可用），保证高可用（https://juejin.cn/post/6844904017387077640）
    - sovle 3: 如果请求压力真的到了mysql：ehcache本地缓存 + Hystrix限流&降级
- 4 先删后写、先写后删除？
  - 4.1 
- 5 redis高并发，高可用？
  - 5.1 高并发(参考：https://cloud.tencent.com/developer/article/1543023)：单机的读速度是有限的，也就几万，采用主从模式的集群达到高并发，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。
    - 如何复制数据到节点的？主从复制是可以断点续传的，新机器加进来，master后台生成rdb(redis db)快照，会做全量复制，网络断了从master节点的backlog上读取上次复制的offset用来继续复制
    - 过期的key？主节点过期就直接淘汰，从节点等主节点发模拟过期的del命令
  - 5.2 高可用：采用哨兵模式实现高可用(应对的问题是：主节点down了，怎么办？)
    - 哨兵就从从结点中发现能够当主节点的，然后让他们成为主节点
    - pros: 主从可以切换, 故障可以转移, 系统可用性就会很好
哨兵模式就是主从模式的升级, 手动到自动, 更加健壮
    - cons: redis 不好在线扩容, 集群容量一旦到达上限, 在线扩容就十分的麻烦
- 6 redis如何保证原子性：
  - redis单线程，在redisAPI层级是能够保证原子性的
  - 但是业务中常有先get后set的并发， 那么可以在客户端中进行并发访问控制
- 7 应用场景？
  - string：cache，限流，分布式锁，计数器，分布式session
  - hash: 中间件对应的消息
  - list: 关注列表时间轴
  - set: 赞，踩，标签
  - zset: 排行榜，友好关系列表

## 数据结构常问问题：
### 实现字典hash?
- key: 使用 MurmurHash2 算法来计算键的哈希值。这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。
- 扩容：每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。之后重新利用murmurhash2算法放到新的hash位置，（这个过程可以使用懒惰更新，避免扩容过程的臃肿时长），迁移完毕后释放原来hash表的位置
- 渐进式rehash：比如扩容的时候，不可能话一段时间去扩容然后不提供查找服务，这个时候老的hash也会参与查找服务，但是插入新数据一定是直接在扩容后去增加
### zset底层实现？
- 跳表实现
  - 为每个节点随机出来一个层数，因此上下两层节点个数不具有严格对应关系
  - 插入只需要修改插入节点的前后指针
- 为什么不用红黑树？
  - 范围查询操作要更加简单 
  - 节点的删除插入只需要修改前后指针，然而红黑树需要调整子树
  - 实现难度低，但是接近的性能

## 数据存储
### 过期策略？
- 以秒为单位的过期时间设置 惰性 + 定期
  - 1 定时删除
  - 2 惰性删除，访问时候过期才删除，不访问不删除
  - 3 定期删除（redis.conf配置一段时间删除所有过期key）

### 持久化？
- RDB快照：redis database快照：某一个时间的redis的数据的快照，用于备份转移恢复，原理导致无法实时性持久化，对于缓存丢失无法忍耐的系统来说不可取
- AOF持久化：(applend only file)：是redis的完全持久化策略，顺序记录每一条改变redis object状态的变更命令
- RDB vs AOF? [https://segmentfault.com/a/1190000039208726#:~:text=%E6%80%BB%E7%BB%93,%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E3%80%82](https://segmentfault.com/a/1190000039208726#:~:text=%E6%80%BB%E7%BB%93,%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E3%80%82)
  - rdb win: 
    - 紧凑二进制文件，适合备份，全量复制，aof文件太大
    - 容易迁移和恢复，数据恢复比AOF性能高(因为毕竟是数据，而不是逻辑日志)
  - rdb loss:
    - 完全持久化办不到
    - 持久化操作导致占用内存加倍
    - redis高并发请求可能频繁命中save规则，导致备份频率不可控制
- 和mysql对比：redo log：innodb的写盘日志，保证事务的持久性，bin log，server层的逻辑日志
- 如何处理过期？
  - 过期的key不会写入rdb和aof文件，同时数据恢复也会做过期验证

### 内存淘汰机制？
内存不足的时候，为保证命中率，也会采用内存页置换策略一样，类似lru cache，但是redis的淘汰机制更为丰富，有random，lru，lfu(使用频率太少)，ttl(将要过期的去淘汰)

## 多线程，和memcacheed的区别？


一些补充问题：
- 红黑树的应用：
  - 进程调度，和epoll管理socket的时候
- 为什么采用红黑树呢?
  - 一句话：主要是因为在一个数据集平凡增删查的需求下，它比其他平衡树都要优秀
  - 因为和epoll的工作机制有关。 epoll在添加一个socket或者删除一个socket或者修改一个socket的时候，它需要查询速度更快，操作效率最高，因此需要一个更加优秀的数据结构能够管理这些socket。



---

# 面试常问问题

## 1 语言方面

## 2 数据库

## 3 网络

## 4 ·